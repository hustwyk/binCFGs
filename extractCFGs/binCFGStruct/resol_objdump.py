import io
import os
import re
from .funcmapping import FuncMapping

class Resol_objdump:
    def __init__(self, file_path):
        self.file_path = file_path
        self.orig_objdump = self.get_objdump()
        self.all_functions = self.get_all_func()  # self.all_functions -> dict
        self.funcMap = FuncMapping()

    def get_objdump(self):
        return os.popen("objdump -j .text -S --no-show-raw-insn -M intel %s"%(self.file_path)).read()

    def get_all_func(self):
        """
        Get all functions info from `objdump -S` result.
        The function info contains two part: function_name, function_body.
        The function_body is an amalgam of asm and C code. 
        
        Returns:
            dict -- The dict contains all function info extracted from `objdump -S`.
                    key:value => function_name:function_body
        """
        functions = {}  # key:value  ->  funcName:funcBody
        tmp_funcName = ''
        tmp_function = ''
        in_func = 0  # Is in the function
        objfile_text_buf = io.StringIO(self.orig_objdump)
        nextLine = objfile_text_buf.readline()
        while 1:
            line = nextLine
            if not line:
                if len(tmp_funcName) and len(tmp_function):
                    functions[tmp_funcName] = tmp_function
                break
            nextLine = objfile_text_buf.readline()
            if not in_func:
                tmp_funcName = ''
                tmp_function = ''
                matchObj = re.match(r'[0-9a-f]+ <.+>:', line, re.M|re.I)
                """
                The re pattern is to catch the line startswith a format like '0000000000000790 <main>:'.
                And the function name can be extracted from the inner of angle brackets.
                """
                if matchObj and not in_func:
                    in_func = 1
                    tmp_funcName = re.findall(r'[0-9a-f]+ <(.+)>:', line)[0]
                    continue
            if in_func:
                if not line == '\n':
                    tmp_function += line
                else:
                    matchObj = re.match(r'[0-9a-f]+ <.+>:', nextLine, re.M|re.I)
                    if matchObj:
                        in_func = 0
                        functions[tmp_funcName] = tmp_function
                    else:
                        tmp_function += line
        return functions

    def struc_func(self, funcBody):
        """
        This function aims to separate the asm code and C code of the funcBody, and establish the corresponding
        of the asm code lines and C code lines.
        
        Example:
            1     #include<stdio.h>
            2     #include<string.h>
            3     int main()
            4     {
            5     790:	push   rbp
            6     791:	mov    rbp,rsp
            7     794:	push   r15
            8     796:	push   r14
            9     798:	push   r13
            10    79a:	push   r12
            11    79c:	push   rbx
            12    79d:	sub    rsp,0xc8
            13    7a4:	mov    rax,QWORD PTR fs:0x28
            14    7ad:	mov    QWORD PTR [rbp-0x38],rax
            15    7b1:	xor    eax,eax
            16        char LocalVar0[15][10]={"     "," .,?\""," abc"," def"," ghi"," jkl"," mno"," pqrs"," tuv"," wxyz"};
            17    7b3:	lea    rdx,[rbp-0xd0]
            18    7ba:	mov    eax,0x0
            19    7bf:	mov    ecx,0x12
            20    7c4:	mov    rdi,rdx
            21    7c7:	rep stos QWORD PTR es:[rdi],rax
            22    7ca:	mov    rdx,rdi
            23    7cd:	mov    DWORD PTR [rdx],eax
            24    7cf:	add    rdx,0x4

        In this part of funcBody, we believe any part of span of the asm adresses from 790 to 7b1 is corresponding to 
        the C code lines from line 1 to line 4. The same as the part of asm adresses from 7b3 to 7cf, it is 
        corresponding to the C code line 16.

        As a word, when confronted with an asm code section, the corresponding C code lines is the nearest C code lines
        generated by `objdump -S` command.

        Arguments:
            funcBody {string} -- The function body of a function which is an amalgam of asm code and C code.
        """
        self.funcMap.clean()
        funcBody_buf = io.StringIO(funcBody)
        nextLine = funcBody_buf.readline()
        tmpCcode = ''
        tmpCcodeOrder = 0
        while 1:
            line = nextLine
            if not line:
                break
            nextLine = funcBody_buf.readline()
            strip_line = line.strip()
            strip_nextLine = nextLine.strip()
            matchObj = re.match(r'[0-9a-f]+:', strip_line, re.M|re.I)
            if matchObj: # This implies this line is in the asm code block
                tmpAddr = re.findall(r'([0-9a-f]+):', strip_line)[0]
                # Correspond this asm line to the C code order
                self.funcMap.address[tmpAddr] = tmpCcodeOrder
                matchNextObj = re.match(r'[0-9a-f]+:', strip_nextLine, re.M|re.I)
                if not matchNextObj:
                    tmpCcode = ''
                    tmpCcodeOrder += 1
            else: # This implies this line is in the C code block
                tmpCcode += line
                matchNextObj = re.match(r'[0-9a-f]+:', strip_nextLine, re.M|re.I)
                if matchNextObj:
                    self.funcMap.ccode[tmpCcodeOrder] = tmpCcode
